#include "QuickGUIPrecompiledHeaders.h"

#include "QuickGUIManager.h"
#include "QuickGUIPanel.h"
#include "QuickGUISheet.h"
#include "QuickGUITextArea.h" 

#ifdef WIN32
// Turn off warnings generated by using 'this' in base member initializer list.
#   pragma warning (disable : 4355)
#endif

namespace QuickGUI
{
	Panel::Panel(const std::string& name, GUIManager* gm) :
		Widget(name,gm),
		QuadContainer(this),
		mScrollingAllowed(false),
		mScrollPane(0),
		mRightScrollBar(0),
		mBottomScrollBar(0)
	{
		mWidgetType = TYPE_PANEL;
		mSkinComponent = ".panel";
		mSize = Size(100,100);

		addEventHandler(EVENT_CHILD_ADDED,&Panel::onChildAdded,this);
		addEventHandler(EVENT_CHILD_REMOVED,&Panel::onChildRemoved,this);
	}

	Panel::~Panel()
	{
		mScrollPane = NULL;
		Widget::removeAndDestroyAllChildWidgets();
		setQuadContainer(NULL);
	}

	Widget*	Panel::_createComponent(const std::string& name, Type t)
	{
		Widget* w;
		switch(t)
		{
			case TYPE_BORDER:				w = new Border(name,mGUIManager);				break;
		    case TYPE_TREE:					w = new Tree(name,mGUIManager);					break;
			case TYPE_BUTTON:				w = new Button(name,mGUIManager);				break;
			case TYPE_CHECKBOX:				w = new CheckBox(name,mGUIManager);				break;
			case TYPE_COMBOBOX:				w = new ComboBox(name,mGUIManager);				break;
			case TYPE_CONSOLE:				w = new Console(name,mGUIManager);				break;
			case TYPE_IMAGE:				w = new Image(name,mGUIManager);				break;
			case TYPE_LABEL:				w = new Label(name,mGUIManager);				break;
			case TYPE_LABELAREA:			w = new LabelArea(name,mGUIManager);			break;
			case TYPE_LIST:					w = new List(name,mGUIManager);					break;
			case TYPE_MENULABEL:			w = new MenuLabel(name,mGUIManager);			break;
			case TYPE_NSTATEBUTTON:			w = new NStateButton(name,mGUIManager);			break;
			case TYPE_PANEL:				w = new Panel(name,mGUIManager);				break;
			case TYPE_PROGRESSBAR:			w = new ProgressBar(name,mGUIManager);			break;
			case TYPE_SCROLL_PANE:			w = new ScrollPane(name,mGUIManager);			break;
			case TYPE_SCROLLBAR_HORIZONTAL: w = new HorizontalScrollBar(name,mGUIManager);	break;
			case TYPE_SCROLLBAR_VERTICAL:	w = new VerticalScrollBar(name,mGUIManager);	break;
			case TYPE_TEXTAREA:				w = new TextArea(name,mGUIManager);				break;
			case TYPE_TEXTBOX:				w = new TextBox(name,mGUIManager);				break;
			case TYPE_TITLEBAR:				w = new TitleBar(name,mGUIManager);				break;
			case TYPE_TRACKBAR_HORIZONTAL:	w = new HorizontalTrackBar(name,mGUIManager);	break;
			case TYPE_TRACKBAR_VERTICAL:	w = new VerticalTrackBar(name,mGUIManager);		break;
			case TYPE_WINDOW:				w = new Window(name,mGUIManager);				break;
			default:						w = new Widget(name,mGUIManager);				break;
		}

		w->setSize(w->getSize());
		// Some Composition widgets will create components before inheritting skin name.
		if(mSkinName != "")
			w->setSkin(mSkinName,true);
		w->setFont(mFontName,true);
		mComponents.push_back(w);
		
		// The setParent method sets the widget's quad container to the
		// quad container the parent belongs to.  However, Sheets, Panels, and Windows
		// are quad containers themselves. So temporarily set mQuadContainer to ourself,
		// make the call to setParent, and then restore the mQuadContainer reference.
		QuadContainer* temp = mQuadContainer;
		mQuadContainer = this;
		w->setParent(this);
		mQuadContainer = temp;

		w->setPosition(0,0);

		if(!mVisible && w->getHideWithParent())
			w->hide();

		return w;
	}

	void Panel::addChild(Widget* w)
	{
		if(w->getParentWidget() != NULL)
			return;

		mChildWidgets.push_back(w);
		
		// The setParent method sets the widget's quad container to the
		// quad container the parent belongs to.  However, Sheets, Panels, and Windows
		// are quad containers themselves. So temporarily set mQuadContainer to ourself,
		// make the call to setParent, and then restore the mQuadContainer reference.
		QuadContainer* temp = mQuadContainer;
		mQuadContainer = this;
		w->setParent(this);
		mQuadContainer = temp;

		// Convert Widget's position to be relative to new parent.
		if(mScrollPane != NULL)
			w->setPosition(w->getScreenPosition() - mScrollPane->getScreenPosition());
		else
			w->setPosition(w->getScreenPosition() - getScreenPosition());

		WidgetEventArgs args(w);
		fireEvent(EVENT_CHILD_ADDED,args);
	}

	void Panel::allowScrolling(bool allow)
	{
		mScrollingAllowed = allow;

		if(mScrollingAllowed)
		{
			if(mScrollPane == NULL)
			{
				mScrollPane = dynamic_cast<ScrollPane*>(_createComponent(mInstanceName+".ScrollPane",TYPE_SCROLL_PANE));
				mScrollPane->setSize(mSize);

				mScrollPane->removeChild(mScrollPane->mRightBar);
				// store reference to the scroll bar
				mRightScrollBar = mScrollPane->mRightBar;
				addChild(mRightScrollBar);
				mRightScrollBar->setPosition(mSize.width - 20,0);
				
				mScrollPane->removeChild(mScrollPane->mBottomBar);
				// store reference to the scroll bar
				mBottomScrollBar = mScrollPane->mBottomBar;
				addChild(mBottomScrollBar);
				mBottomScrollBar->setPosition(0,mSize.height - 20);

				mScrollPane->manageWidgets();
			}
		}
		else
		{
			if(mScrollPane != NULL)
			{
				delete mScrollPane;
				mScrollPane = NULL;

				mGUIManager->destroyWidget(mRightScrollBar);
				mRightScrollBar = NULL;
				mGUIManager->destroyWidget(mBottomScrollBar);
				mBottomScrollBar = NULL;
			}
		}
	}

   Tree* Panel::createTree()
   {
      return createTree(mGUIManager->generateName(TYPE_TREE));
   }

   Tree* Panel::createTree(const std::string& name)
   {
      if(mGUIManager->isNameUnique(name))
      {
         mGUIManager->notifyNameUsed(name);
         return dynamic_cast<Tree*>(_createChild(name,TYPE_TREE));
      }
      else
      {
         std::string name = mGUIManager->generateName(TYPE_TREE);
         mGUIManager->notifyNameUsed(name);
         return dynamic_cast<Tree*>(_createChild(name,TYPE_TREE));
      }
	}	 

	Button* Panel::createButton()
	{
		return createButton(mGUIManager->generateName(TYPE_BUTTON));
	}

	Button* Panel::createButton(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Button*>(_createChild(name,TYPE_BUTTON));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_BUTTON);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Button*>(_createChild(name,TYPE_BUTTON));
		}
	}

	CheckBox* Panel::createCheckBox()
	{
		return createCheckBox(mGUIManager->generateName(TYPE_CHECKBOX));
	}

	CheckBox* Panel::createCheckBox(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<CheckBox*>(_createChild(name,TYPE_CHECKBOX));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_CHECKBOX);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<CheckBox*>(_createChild(name,TYPE_CHECKBOX));
		}
	}

	ComboBox* Panel::createComboBox()
	{
		return createComboBox(mGUIManager->generateName(TYPE_COMBOBOX));
	}

	ComboBox* Panel::createComboBox(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<ComboBox*>(_createChild(name,TYPE_COMBOBOX));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_COMBOBOX);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<ComboBox*>(_createChild(name,TYPE_COMBOBOX));
		}
	}

	Console* Panel::createConsole()
	{
		return createConsole(mGUIManager->generateName(TYPE_CONSOLE));
	}

	Console* Panel::createConsole(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Console*>(_createChild(name,TYPE_CONSOLE));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_CONSOLE);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Console*>(_createChild(name,TYPE_CONSOLE));
		}
	}

	HorizontalScrollBar* Panel::createHorizontalScrollBar()
	{
		return createHorizontalScrollBar(mGUIManager->generateName(TYPE_SCROLLBAR_HORIZONTAL));

/*		HorizontalScrollBar* sb = dynamic_cast<HorizontalScrollBar*>(_createChild(TYPE_SCROLLBAR_HORIZONTAL));

		sb->setSkin(mSkinName);

		sb->mSlider = dynamic_cast<Button*>(sb->_createComponent(TYPE_BUTTON));
		sb->mSlider->setSkinComponent(".scrollbar.horizontal.slider");
		sb->mSlider->setSize(sb->getHeight(),sb->getHeight());
		sb->mSlider->setPosition(sb->getHeight(),0);
		sb->mSlider->setVerticalAnchor(ANCHOR_VERTICAL_TOP_BOTTOM);
		sb->mSlider->enableDragging(true);
		sb->mSlider->constrainDragging(true,false);
		sb->mSlider->setAutoSize(false);
		sb->mSlider->addEventHandler(EVENT_DRAGGED,&HorizontalScrollBar::onSliderDragged,sb);

		float scrollBarHeight = mSize.height;
		sb->mScrollLeft1 = dynamic_cast<Button*>(sb->_createComponent(TYPE_BUTTON));
		sb->mScrollLeft1->setSkinComponent(".scrollbar.horizontal.left");
		sb->mScrollLeft1->setSize(sb->getHeight(),sb->getHeight());
		sb->mScrollLeft1->setPosition(0,0);
		sb->mScrollLeft1->setAutoSize(false);
		sb->mScrollLeft1->setVerticalAnchor(ANCHOR_VERTICAL_TOP_BOTTOM);
		sb->mScrollLeft1->addEventHandler(EVENT_MOUSE_BUTTON_DOWN,&HorizontalScrollBar::onScrollLeftDown,sb);

		sb->mScrollRight1 = dynamic_cast<Button*>(sb->_createComponent(TYPE_BUTTON));
		sb->mScrollRight1->setSkinComponent(".scrollbar.horizontal.right");
		sb->mScrollRight1->setSize(sb->getHeight(),sb->getHeight());
		sb->mScrollRight1->setPosition(sb->getHeight(),0);
		sb->mScrollRight1->setAutoSize(false);
		sb->mScrollRight1->setVerticalAnchor(ANCHOR_VERTICAL_TOP_BOTTOM);
		sb->mScrollRight1->setShowWithParent(false);
		sb->mScrollRight1->addEventHandler(EVENT_MOUSE_BUTTON_DOWN,&HorizontalScrollBar::onScrollRightDown,sb);

		sb->mScrollLeft2 = dynamic_cast<Button*>(sb->_createComponent(TYPE_BUTTON));
		sb->mScrollLeft2->setSkinComponent(".scrollbar.horizontal.left");
		sb->mScrollLeft2->setSize(sb->getHeight(),sb->getHeight());
		sb->mScrollLeft2->setPosition(sb->getWidth() - (sb->getHeight()*2.0),0);
		sb->mScrollLeft2->setAutoSize(false);
		sb->mScrollLeft2->setHorizontalAnchor(ANCHOR_HORIZONTAL_RIGHT);
		sb->mScrollLeft2->setVerticalAnchor(ANCHOR_VERTICAL_TOP_BOTTOM);
		sb->mScrollLeft2->setShowWithParent(false);
		sb->mScrollLeft2->addEventHandler(EVENT_MOUSE_BUTTON_DOWN,&HorizontalScrollBar::onScrollLeftDown,sb);
		
		sb->mScrollRight2 = dynamic_cast<Button*>(sb->_createComponent(TYPE_BUTTON));
		sb->mScrollRight2->setSkinComponent(".scrollbar.horizontal.right");
		sb->mScrollRight2->setSize(sb->getHeight(),sb->getHeight());
		sb->mScrollRight2->setPosition(sb->getWidth() - sb->getHeight(),0);
		sb->mScrollRight2->setAutoSize(false);
		sb->mScrollRight2->setHorizontalAnchor(ANCHOR_HORIZONTAL_RIGHT);
		sb->mScrollRight2->setVerticalAnchor(ANCHOR_VERTICAL_TOP_BOTTOM);
		sb->mScrollRight2->addEventHandler(EVENT_MOUSE_BUTTON_DOWN,&HorizontalScrollBar::onScrollRightDown,sb);

		sb->mMinSliderPosition = sb->mScrollRight1->getXPosition();
		sb->mMaxSliderPosition = sb->mScrollRight2->getXPosition();

		sb->mInitialized = true;

		return sb;
*/	}

	HorizontalScrollBar* Panel::createHorizontalScrollBar(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<HorizontalScrollBar*>(_createChild(name,TYPE_SCROLLBAR_HORIZONTAL));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_SCROLLBAR_HORIZONTAL);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<HorizontalScrollBar*>(_createChild(name,TYPE_SCROLLBAR_HORIZONTAL));
		}
	}

	HorizontalTrackBar* Panel::createHorizontalTrackBar()
	{
		return createHorizontalTrackBar(mGUIManager->generateName(TYPE_TRACKBAR_HORIZONTAL));
	}

	HorizontalTrackBar* Panel::createHorizontalTrackBar(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<HorizontalTrackBar*>(_createChild(name,TYPE_TRACKBAR_HORIZONTAL));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_TRACKBAR_HORIZONTAL);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<HorizontalTrackBar*>(_createChild(name,TYPE_TRACKBAR_HORIZONTAL));
		}
	}

	Image* Panel::createImage()
	{
		return createImage(mGUIManager->generateName(TYPE_IMAGE));
	}

	Image* Panel::createImage(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Image*>(_createChild(name,TYPE_IMAGE));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_IMAGE);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Image*>(_createChild(name,TYPE_IMAGE));
		}
	}

	Label* Panel::createLabel()
	{
		return createLabel(mGUIManager->generateName(TYPE_LABEL));
	}

	Label* Panel::createLabel(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Label*>(_createChild(name,TYPE_LABEL));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_LABEL);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Label*>(_createChild(name,TYPE_LABEL));
		}
	}

	List* Panel::createList()
	{
		return createList(mGUIManager->generateName(TYPE_LIST));
	}

	List* Panel::createList(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<List*>(_createChild(name,TYPE_LIST));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_LIST);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<List*>(_createChild(name,TYPE_LIST));
		}
	}

	LabelArea* Panel::createMultiLineLabel()
	{
		return createMultiLineLabel(mGUIManager->generateName(TYPE_LABELAREA));
	}

	LabelArea* Panel::createMultiLineLabel(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<LabelArea*>(_createChild(name,TYPE_LABELAREA));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_LABELAREA);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<LabelArea*>(_createChild(name,TYPE_LABELAREA));
		}
	}

	NStateButton* Panel::createNStateButton()
	{
		return createNStateButton(mGUIManager->generateName(TYPE_NSTATEBUTTON));
	}

	NStateButton* Panel::createNStateButton(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<NStateButton*>(_createChild(name,TYPE_NSTATEBUTTON));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_NSTATEBUTTON);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<NStateButton*>(_createChild(name,TYPE_NSTATEBUTTON));
		}
	}

	Panel* Panel::createPanel()
	{
		return createPanel(mGUIManager->generateName(TYPE_PANEL));
	}

	Panel* Panel::createPanel(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Panel*>(_createChild(name,TYPE_PANEL));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_PANEL);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<Panel*>(_createChild(name,TYPE_PANEL));
		}
	}

	ProgressBar* Panel::createProgressBar()
	{
		return createProgressBar(mGUIManager->generateName(TYPE_PROGRESSBAR));
	}

	ProgressBar* Panel::createProgressBar(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<ProgressBar*>(_createChild(name,TYPE_PROGRESSBAR));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_PROGRESSBAR);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<ProgressBar*>(_createChild(name,TYPE_PROGRESSBAR));
		}
	}

	TextBox* Panel::createTextBox()
	{
		return createTextBox(mGUIManager->generateName(TYPE_TEXTBOX));
	}

	TextBox* Panel::createTextBox(const std::string& name)
	{
		TextBox* tb;
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			tb = dynamic_cast<TextBox*>(_createChild(name,TYPE_TEXTBOX));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_TEXTBOX);
			mGUIManager->notifyNameUsed(name);
			tb = dynamic_cast<TextBox*>(_createChild(name,TYPE_TEXTBOX));
		}

		tb->setUseBorders(true);
		tb->setSkin(mSkinName,true);

		return tb;
	}

	VerticalScrollBar* Panel::createVerticalScrollBar()
	{
		return createVerticalScrollBar(mGUIManager->generateName(TYPE_SCROLLBAR_VERTICAL));
	}

	VerticalScrollBar* Panel::createVerticalScrollBar(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<VerticalScrollBar*>(_createChild(name,TYPE_SCROLLBAR_VERTICAL));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_SCROLLBAR_VERTICAL);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<VerticalScrollBar*>(_createChild(name,TYPE_SCROLLBAR_VERTICAL));
		}
	}

	VerticalTrackBar* Panel::createVerticalTrackBar()
	{
		return createVerticalTrackBar(mGUIManager->generateName(TYPE_TRACKBAR_VERTICAL));
	}

	VerticalTrackBar* Panel::createVerticalTrackBar(const std::string& name)
	{
		if(mGUIManager->isNameUnique(name))
		{
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<VerticalTrackBar*>(_createChild(name,TYPE_TRACKBAR_VERTICAL));
		}
		else
		{
			std::string name = mGUIManager->generateName(TYPE_TRACKBAR_VERTICAL);
			mGUIManager->notifyNameUsed(name);
			return dynamic_cast<VerticalTrackBar*>(_createChild(name,TYPE_TRACKBAR_VERTICAL));
		}
	}

	ScrollPane* Panel::getScrollPane()
	{
		return mScrollPane;
	}

	Widget* Panel::getTargetWidget(const Point& pixelPosition)
	{
		Widget* w = NULL;

		if( !mVisible || !mEnabled )
			return w;

		for(WidgetArray::iterator it = mComponents.begin(); it != mComponents.end(); ++it)
		{
			if((w = (*it)->getTargetWidget(pixelPosition)) != NULL)
				return w;
		}

		// If position is not inside this widget, it can't be inside a child widget. (except menus, which are handled differently)
		if(!isPointWithinBounds(pixelPosition))
			return NULL;

		// Iterate through Menu Layer Child Widgets.
		int widgetOffset = 0;
		WidgetArray::iterator it;
		for( it = mChildWidgets.begin(); it != mChildWidgets.end(); ++it )
		{
			if( (*it)->getQuadLayer() == Quad::LAYER_CHILD )
				continue;

			Widget* temp = (*it)->getTargetWidget(pixelPosition);
			if( (temp != NULL) && (temp->getOffset() > widgetOffset) )
			{
				widgetOffset = temp->getOffset();
				w = temp;
			}
		}
		if(w != NULL)
			return w;

		// Iterate through Panels, from highest offset to lowest.
		QuadContainerList* panelList = QuadContainer::getPanelList();
		QuadContainerList::reverse_iterator rit;
		for( rit = panelList->rbegin(); rit != panelList->rend(); ++rit )
		{
			if( (w = (*rit)->getOwner()->getTargetWidget(pixelPosition)) != NULL )
				return w;
		}

		// Iterate through Child Layer Child Widgets.
		widgetOffset = 0;
		for( it = mChildWidgets.begin(); it != mChildWidgets.end(); ++it )
		{
			if( (*it)->getQuadLayer() == Quad::LAYER_MENU )
				continue;

			Widget* temp = (*it)->getTargetWidget(pixelPosition);
			if( (temp != NULL) && (temp->getOffset() > widgetOffset) )
			{
				widgetOffset = temp->getOffset();
				w = temp;
			}
		}
		if(w != NULL)
			return w;

		return this;
	}

	void Panel::onChildAdded(const EventArgs& args)
	{
		if(mScrollPane != NULL)
			mScrollPane->onChildAddedToParent(args);
	}

	void Panel::onChildRemoved(const EventArgs& args)
	{
		if(mScrollPane != NULL)
			mScrollPane->onChildRemovedFromParent(args);
	}

	void Panel::onSizeChanged(const EventArgs& args)
	{
		Widget::onSizeChanged(args);

		if(mScrollPane != NULL)
			mScrollPane->onParentSizeChanged(args);
	}

	void Panel::setQuadContainer(QuadContainer* c)
	{
		if((mQuadContainer != NULL) && (c != mQuadContainer))
			mQuadContainer->removeChildPanelContainer(this);

		mQuadContainer = c;

		if(mQuadContainer != NULL)
			mQuadContainer->addChildPanelContainer(this);
	}

	bool Panel::scrollingAllowed()
	{
		return mScrollingAllowed;
	}

	void Panel::show()
	{
		Widget::show();

		if(mScrollPane != NULL)
			mScrollPane->_syncBarWithParentDimensions();
	}
}
